# === AI SIGNATURE ===
# Created by: Claude (opus-4)
# Created at: 2026-01-27T14:00:00Z
# Purpose: Abstract base class for trading strategies
# === END SIGNATURE ===
"""
Base Strategy Module.

Defines the abstract interface for all trading strategies.
Strategies must implement analyze() method.

Pattern: Strategy Pattern + Template Method
"""
from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Literal, Optional, Any
import hashlib
import json


class SignalDirection(str, Enum):
    """Signal direction."""
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"


@dataclass(frozen=True)
class StrategyConfig:
    """
    Strategy configuration.

    Immutable to prevent runtime changes.
    """
    # Risk parameters
    risk_per_trade: float = 0.02  # 2% of portfolio
    max_position_pct: float = 0.10  # 10% max per position
    stop_loss_atr_mult: float = 2.0  # SL = ATR * multiplier
    take_profit_atr_mult: float = 3.0  # TP = ATR * multiplier

    # Signal thresholds
    min_strength: float = 0.5  # Minimum signal strength to trade
    min_confidence: float = 0.5  # Minimum confidence

    # Timeframe
    primary_timeframe: str = "1h"  # Main analysis timeframe

    # Strategy-specific (override in subclass)
    params: dict = field(default_factory=dict)


@dataclass
class StrategySignal:
    """
    Trading signal generated by strategy.

    Contains all information needed for execution.
    """
    signal_id: str  # sha256:xxx
    timestamp: datetime
    strategy_name: str

    # Core signal
    symbol: str
    direction: SignalDirection
    strength: float  # 0.0-1.0
    confidence: float  # 0.0-1.0

    # Entry/Exit
    entry_price: float
    stop_loss: float
    take_profit: float
    risk_reward_ratio: float

    # Context
    timeframe: str
    indicators: dict[str, Any]
    reasoning: str
    expires_at: datetime

    # Metadata
    raw_scores: dict[str, float] = field(default_factory=dict)

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "signal_id": self.signal_id,
            "timestamp": self.timestamp.isoformat(),
            "strategy_name": self.strategy_name,
            "symbol": self.symbol,
            "direction": self.direction.value,
            "strength": self.strength,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "risk_reward_ratio": self.risk_reward_ratio,
            "timeframe": self.timeframe,
            "indicators": self.indicators,
            "reasoning": self.reasoning,
            "expires_at": self.expires_at.isoformat(),
            "raw_scores": self.raw_scores,
        }

    @staticmethod
    def generate_id(
        symbol: str,
        direction: SignalDirection,
        timestamp: datetime,
        strategy: str,
    ) -> str:
        """Generate deterministic signal ID."""
        data = f"{symbol}:{direction.value}:{timestamp.isoformat()}:{strategy}"
        hash_hex = hashlib.sha256(data.encode()).hexdigest()[:16]
        return f"sha256:{hash_hex}"


@dataclass
class MarketData:
    """
    Market data for strategy analysis.

    Contains OHLCV and derived data.
    """
    symbol: str
    timeframe: str
    timestamp: datetime

    # OHLCV arrays (oldest first)
    opens: list[float]
    highs: list[float]
    lows: list[float]
    closes: list[float]
    volumes: list[float]

    # Current price
    current_price: float

    # Optional: pre-calculated indicators
    indicators: dict[str, Any] = field(default_factory=dict)

    @property
    def last_close(self) -> float:
        """Get last closing price."""
        return self.closes[-1] if self.closes else self.current_price


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    Subclasses must implement:
    - analyze(): Generate signal from market data
    - name: Strategy identifier

    Template methods provided:
    - calculate_position_size()
    - validate_signal()
    """

    name: str = "base"
    description: str = "Abstract base strategy"

    def __init__(self, config: StrategyConfig | None = None):
        """
        Initialize strategy.

        Args:
            config: Strategy configuration (default if None)
        """
        self.config = config or StrategyConfig()
        self._last_signal: StrategySignal | None = None

    @abstractmethod
    def analyze(self, data: MarketData) -> StrategySignal | None:
        """
        Analyze market data and generate signal.

        This is the main strategy logic.

        Args:
            data: Market data with OHLCV

        Returns:
            StrategySignal if conditions met, None otherwise
        """
        pass

    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate signal meets minimum thresholds.

        Args:
            signal: Generated signal

        Returns:
            True if signal is valid, False otherwise
        """
        if signal.strength < self.config.min_strength:
            return False

        if signal.confidence < self.config.min_confidence:
            return False

        if signal.risk_reward_ratio < 1.0:
            return False

        if signal.direction == SignalDirection.NEUTRAL:
            return False

        return True

    def calculate_entry_exit(
        self,
        direction: SignalDirection,
        current_price: float,
        atr: float,
    ) -> tuple[float, float, float, float]:
        """
        Calculate entry, stop loss, take profit prices.

        Args:
            direction: Signal direction
            current_price: Current market price
            atr: Average True Range

        Returns:
            (entry_price, stop_loss, take_profit, risk_reward_ratio)
        """
        entry_price = current_price
        sl_distance = atr * self.config.stop_loss_atr_mult
        tp_distance = atr * self.config.take_profit_atr_mult

        if direction == SignalDirection.LONG:
            stop_loss = entry_price - sl_distance
            take_profit = entry_price + tp_distance
        else:  # SHORT
            stop_loss = entry_price + sl_distance
            take_profit = entry_price - tp_distance

        risk = abs(entry_price - stop_loss)
        reward = abs(take_profit - entry_price)
        rr_ratio = reward / risk if risk > 0 else 0

        return (
            round(entry_price, 8),
            round(stop_loss, 8),
            round(take_profit, 8),
            round(rr_ratio, 2),
        )

    def get_last_signal(self) -> StrategySignal | None:
        """Get the last generated signal."""
        return self._last_signal

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} name={self.name}>"
