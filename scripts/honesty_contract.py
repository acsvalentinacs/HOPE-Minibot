# -*- coding: utf-8 -*-
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
#                    ĞšĞĞĞ¢Ğ ĞĞšĞ¢ Ğ§Ğ•Ğ¡Ğ¢ĞĞĞ¡Ğ¢Ğ˜ CLAUDE â†” Ğ’ĞĞ›Ğ•ĞĞ¢Ğ˜Ğ
#                              AI System v2.0
#
#                    Ğ“Ğ›ĞĞ‘ĞĞ›Ğ¬ĞĞ«Ğ™ - Ğ’Ğ¡Ğ• ĞŸĞ ĞĞ•ĞšĞ¢Ğ«, Ğ’Ğ¡Ğ• ĞĞ¢Ğ’Ğ•Ğ¢Ğ«
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# sha256: honesty_contract_global_v2.0
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
ĞšĞĞĞ¢Ğ ĞĞšĞ¢ Ğ§Ğ•Ğ¡Ğ¢ĞĞĞ¡Ğ¢Ğ˜ CLAUDE â†” Ğ’ĞĞ›Ğ•ĞĞ¢Ğ˜Ğ | AI System v2.0

Ğ“Ğ›ĞĞ‘ĞĞ›Ğ¬ĞĞ«Ğ™ ĞœĞĞ”Ğ£Ğ›Ğ¬ - Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ ĞºĞ¾ Ğ’Ğ¡Ğ•Ğœ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°Ğ¼, Ğ’Ğ¡Ğ•Ğœ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°Ğ¼.

ĞĞ‘Ğ¡ĞĞ›Ğ®Ğ¢ĞĞ«Ğ• Ğ—ĞĞŸĞ Ğ•Ğ¢Ğ«:
- Ğ¤ĞµĞ¹ĞºĞ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ (random, hardcoded, ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ğ±ĞµĞ· Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸)
- Ğ—Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ¸ Ğ±ĞµĞ· ÑĞ²Ğ½Ğ¾Ğ¹ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ [STUB]
- Ğ˜ÑĞºĞ°Ğ¶ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸ (ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº â‰  "ĞºĞ¾Ñ€Ñ€ĞµĞºÑ†Ğ¸Ñ")
- ĞĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‘Ğ½Ğ½Ñ‹Ğµ Ñ„Ğ¾Ñ€Ğ¼ÑƒĞ»Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸ ("Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½Ğ¾", "ÑĞºĞ¾Ñ€Ğ¾", "Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ")

ĞĞ‘Ğ¡ĞĞ›Ğ®Ğ¢ĞĞ«Ğ• ĞĞ‘Ğ¯Ğ—ĞĞ¢Ğ•Ğ›Ğ¬Ğ¡Ğ¢Ğ’Ğ:
- Ğ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ˜Ğ›Ğ˜ ÑĞ²Ğ½Ğ¾Ğµ "ĞĞ•Ğ¢ Ğ”ĞĞĞĞ«Ğ¥"
- ĞœĞ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°: [Ğ Ğ•ĞĞ›Ğ¬ĞĞĞ•], [Ğ¡Ğ˜ĞœĞ£Ğ›Ğ¯Ğ¦Ğ˜Ğ¯], [ĞĞ¦Ğ•ĞĞšĞ], [STUB]
- ĞŸÑ€Ğ¸Ğ·Ğ½Ğ°Ğ½Ğ¸Ğµ: "Ğ½Ğµ Ğ·Ğ½Ğ°Ñ", "Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ", "Ğ¼Ğ¾Ğ³Ñƒ Ğ¾ÑˆĞ¸Ğ±Ğ°Ñ‚ÑŒÑÑ"
- ĞÑ‚Ñ‡Ñ‘Ñ‚ Ğ¾ Ğ’Ğ¡Ğ•Ğ¥ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°Ñ…, Ñ€Ğ¸ÑĞºĞ°Ñ…, Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸ÑÑ…

ĞŸĞ Ğ˜ĞĞ¦Ğ˜ĞŸ: Ğ Ğ•ĞĞ›Ğ¬ĞĞ«Ğ™ Ğ£Ğ‘Ğ«Ğ¢ĞĞš -10% Ğ»ÑƒÑ‡ÑˆĞµ Ñ‡ĞµĞ¼ Ğ¤Ğ•Ğ™ĞšĞĞ’ĞĞ¯ ĞŸĞ Ğ˜Ğ‘Ğ«Ğ›Ğ¬ +20%
"""

import functools
import logging
import math
from datetime import datetime, timezone
from typing import Any, Optional, Dict, List, Union
from dataclasses import dataclass, field
from enum import Enum

__version__ = "2.0"
__contract__ = "ĞšĞĞĞ¢Ğ ĞĞšĞ¢ Ğ§Ğ•Ğ¡Ğ¢ĞĞĞ¡Ğ¢Ğ˜ CLAUDE â†” Ğ’ĞĞ›Ğ•ĞĞ¢Ğ˜Ğ | AI System"

logger = logging.getLogger(__name__)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXCEPTIONS - ĞĞĞ Ğ£Ğ¨Ğ•ĞĞ˜Ğ¯ ĞšĞĞĞ¢Ğ ĞĞšĞ¢Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HonestyViolation(Exception):
    """
    ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§Ğ•Ğ¡ĞšĞĞ• Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ° Ñ‡ĞµÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸.
    
    Ğ­Ñ‚Ğ¾ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ĞĞ•Ğ›Ğ¬Ğ—Ğ¯ Ğ»Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¸ Ğ¸Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ!
    """
    pass


class DataUnavailable(Exception):
    """Ğ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹ - ÑÑ‚Ğ¾ ĞĞ• Ğ¾ÑˆĞ¸Ğ±ĞºĞ°, ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ."""
    pass


class IntegrityError(Exception):
    """ĞĞ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ğµ Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…."""
    pass


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STATUS MARKERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Status(str, Enum):
    """ĞĞ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑÑ‚Ğ°Ñ‚ÑƒÑÑ‹ Ğ´Ğ»Ñ Ğ»ÑĞ±Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…."""
    REAL = "Ğ Ğ•ĞĞ›Ğ¬ĞĞĞ•"
    SIMULATED = "Ğ¡Ğ˜ĞœĞ£Ğ›Ğ¯Ğ¦Ğ˜Ğ¯"
    ESTIMATE = "ĞĞ¦Ğ•ĞĞšĞ"
    STUB = "STUB"
    UNTESTED = "UNTESTED"
    BROKEN = "BROKEN"
    UNKNOWN = "ĞĞ•Ğ˜Ğ—Ğ’Ğ•Ğ¡Ğ¢ĞĞ"
    
    def __str__(self) -> str:
        return f"[{self.value}]"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VERIFICATION FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def verify_numeric(
    value: Union[int, float],
    name: str,
    min_val: float = None,
    max_val: float = None,
    allow_zero: bool = True,
    allow_negative: bool = True,
    source: str = "unknown"
) -> float:
    """Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€ÑƒĞµÑ‚ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. ĞĞ˜ĞšĞĞ“Ğ”Ğ Ğ½Ğµ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ñ„ĞµĞ¹Ğº!"""
    
    if value is None:
        raise DataUnavailable(f"{name} is None (source: {source})")
    
    if math.isnan(value) or math.isinf(value):
        raise HonestyViolation(f"{name} is NaN/Inf - invalid data!")
    
    if value == 0 and not allow_zero:
        raise DataUnavailable(f"{name} is 0 - no data (source: {source})")
    
    if value < 0 and not allow_negative:
        raise HonestyViolation(f"{name} is negative ({value}) - invalid!")
    
    if min_val is not None and value < min_val:
        raise IntegrityError(f"{name} = {value} < min {min_val}")
    if max_val is not None and value > max_val:
        raise IntegrityError(f"{name} = {value} > max {max_val}")
    
    # Suspicious hardcoded values
    suspicious = [1.0, 10.0, 100.0, 1000.0, 0.1, 0.01, 999, -999, 42]
    if value in suspicious:
        logger.warning(f"HONESTY: {name}={value} is suspicious. Verify it's real!")
    
    return float(value)


def verify_price(price: float, symbol: str, source: str = "unknown") -> float:
    """Ğ’ĞµÑ€Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ñ†ĞµĞ½Ñ‹ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ²Ğ°Ğ»ÑÑ‚Ñ‹."""
    return verify_numeric(price, f"Price({symbol})", min_val=0, 
                         allow_zero=False, allow_negative=False, source=source)


def verify_pnl(entry: float, exit: float, qty: float, side: str = "LONG") -> Dict:
    """Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµÑ‚ Ğ Ğ•ĞĞ›Ğ¬ĞĞ«Ğ™ PnL. Ğ£Ğ±Ñ‹Ñ‚Ğ¾Ğº = ÑƒĞ±Ñ‹Ñ‚Ğ¾Ğº!"""
    verify_numeric(entry, "entry", min_val=0, allow_zero=False, allow_negative=False)
    verify_numeric(exit, "exit", min_val=0, allow_zero=False, allow_negative=False)
    verify_numeric(qty, "quantity", min_val=0, allow_zero=False, allow_negative=False)
    
    if side.upper() == "LONG":
        pnl_pct = (exit - entry) / entry * 100
    else:
        pnl_pct = (entry - exit) / entry * 100
    
    return {
        "pnl_pct": pnl_pct,  # ĞœĞĞ–Ğ•Ğ¢ Ğ‘Ğ«Ğ¢Ğ¬ ĞĞ¢Ğ Ğ˜Ğ¦ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğœ!
        "pnl_usdt": pnl_pct / 100 * (entry * qty),
        "entry": entry, "exit": exit, "qty": qty, "side": side
    }


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DECORATORS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def require_honesty(func):
    """Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€: Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°Ñ‚ÑŒ Ñ‡ĞµÑÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        if isinstance(result, (int, float)) and result in [1.0, 10.0, 100.0, 0.1, 999, 42]:
            logger.warning(f"HONESTY: {func.__name__}()={result} - verify real!")
        return result
    return wrapper


def fail_closed(func):
    """Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€: fail-closed, ĞĞ• Ğ¿Ğ¾Ğ´Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ."""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except (HonestyViolation, DataUnavailable):
            raise
        except Exception as e:
            logger.error(f"FAIL-CLOSED: {func.__name__}() failed: {e}")
            raise
    return wrapper


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REPORT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def report_honest(title: str, data: Dict, problems: List[str] = None, 
                  mode: str = None) -> str:
    """Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ Ñ‡ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚ Ñ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼."""
    lines = ["â•" * 60, f"  {title}"]
    if mode:
        lines.append(f"  Ğ Ğ•Ğ–Ğ˜Ğœ: {mode}")
    lines.extend([f"  Ğ’Ğ Ğ•ĞœĞ¯: {datetime.now(timezone.utc).isoformat()}", "â•" * 60, ""])
    
    for key, val in data.items():
        mark = " ğŸ“‰" if isinstance(val, (int, float)) and val < 0 else ""
        lines.append(f"  {key}: {val}{mark}")
    
    if problems:
        lines.extend(["", "âš ï¸ ĞŸĞ ĞĞ‘Ğ›Ğ•ĞœĞ«:"])
        for p in problems:
            lines.append(f"  â€¢ {p}")
    
    lines.extend(["", "â”€" * 60, 
                  "ĞšĞĞĞ¢Ğ ĞĞšĞ¢: Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ. Ğ£Ğ±Ñ‹Ñ‚ĞºĞ¸ = ÑƒĞ±Ñ‹Ñ‚ĞºĞ¸.", "â•" * 60])
    return "\n".join(lines)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CODE CHECK
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VIOLATIONS = [
    ("random.random()", "Fake random data"),
    ("random.uniform(", "Fake random data"),
    ("# TODO", "Unfinished code"),
    ("# FIXME", "Known bug"),
    ("pass  #", "Empty implementation"),
    ("return 0.0  #", "Suspicious default"),
]

def check_code(filepath: str) -> Dict:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ ĞºĞ¾Ğ´ Ğ½Ğ° Ğ½Ğ°Ñ€ÑƒÑˆĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ğ°."""
    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
        lines = f.readlines()
    
    violations = []
    for i, line in enumerate(lines, 1):
        for pattern, desc in VIOLATIONS:
            if pattern.lower() in line.lower():
                violations.append({"line": i, "pattern": pattern, "desc": desc})
    
    return {"filepath": filepath, "violations": violations, 
            "is_clean": len(violations) == 0}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONTRACT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CONTRACT = {
    "name": "HONESTY CONTRACT CLAUDE <-> VALENTIN | AI System",
    "version": "2.0",
    "scope": "GLOBAL - ALL projects, ALL responses",
    "status": "ACTIVE | PERMANENT | NON-NEGOTIABLE",
    "principles": [
        "NO fake data",
        "NO stubs without marking",
        "NO vague formulations",
        "ALWAYS real data or explicit exception",
        "ALWAYS honest metrics including losses",
        "REAL LOSS is better than FAKE PROFIT",
    ],
}

def print_contract():
    print("=" * 70)
    print(f"  {CONTRACT['name']}")
    print(f"  v{CONTRACT['version']} | {CONTRACT['scope']}")
    print("=" * 70)
    for p in CONTRACT['principles']:
        print(f"  [+] {p}")
    print("=" * 70)


if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1 and sys.argv[1] == "--check":
        result = check_code(sys.argv[2])
        status = "CLEAN" if result['is_clean'] else "VIOLATIONS"
        print(f"\n{status}: {result['filepath']}")
        for v in result['violations']:
            print(f"  Line {v['line']}: {v['desc']}")
        sys.exit(0 if result['is_clean'] else 1)
    else:
        print_contract()
